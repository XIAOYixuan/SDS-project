###############################################################################
#
# Copyright 2020, University of Stuttgart: Institute for Natural Language Processing (IMS)
#
# This file is part of Adviser.
# Adviser is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3.
#
# Adviser is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Adviser.  If not, see <https://www.gnu.org/licenses/>.
#
###############################################################################

"""Handcrafted (i.e. template-based) Natural Language Generation Module"""

import inspect
import os

from services.nlg.templates.templatefile import TemplateFile
from services.service import PublishSubscribe
from services.service import Service
from utils.common import Language
from utils.domain.domain import Domain
from utils.logger import DiasysLogger
from utils.sysact import SysAct, SysActionType
from typing import Dict


class HandcraftedNLG(Service):
    """Handcrafted (i.e. template-based) Natural Language Generation Module

    A rule-based approach on natural language generation.
    The rules have to be specified within a template file using the ADVISER NLG syntax.
    Python methods that are called within a template file must be specified in the
    HandcraftedNLG class by using the prefix "_template_". For example, the method
    "_template_genitive_s" can be accessed in the template file via calling {genitive_s(name)}

    Attributes:
        domain (Domain): the domain
        template_filename (str): the NLG template filename
        templates (TemplateFile): the parsed and ready-to-go NLG template file
        template_english (str): the name of the English NLG template file
        template_german (str): the name of the German NLG template file
        language (Language): the language of the dialogue
    """
    def __init__(self, domain: Domain, template_file: str = None, sub_topic_domains: Dict[str, str] = {},
                 logger: DiasysLogger = DiasysLogger(), template_file_german: str = None,
                 language: Language = None):
        """Constructor mainly extracts methods and rules from the template file"""
        Service.__init__(self, domain=domain, sub_topic_domains=sub_topic_domains)

        self.language = language if language else Language.ENGLISH
        self.template_english = template_file
        # TODO: at some point if we expand languages, maybe make kwargs? --LV
        self.template_german = template_file_german
        self.domain = domain
        self.template_filename = None
        self.templates = None
        self.logger = logger

        self.language = Language.ENGLISH
        self._initialise_language(self.language)


    @PublishSubscribe(sub_topics=["sys_act"], pub_topics=["sys_utterance"])
    def publish_system_utterance(self, sys_act: SysAct = None) -> dict(sys_utterance=str):
        """Generates the system utterance and publishes it.

        Args:
            sys_act (SysAct): The system act published by the policy

        Returns:
            dict: a dict containing the system utterance
        """
        return {'sys_utterance': self.generate_system_utterance(sys_act)}


    def generate_system_utterance(self, sys_act: SysAct = None) -> str:
        """Main function of the NLG module

        Takes a system act, searches for a fitting rule, applies it and returns the message.
        Overwrite this function if you inherit from the NLG module.

        Args:
            sys_act (SysAct): The system act

        Returns:
            The utterance generated by applying a fitting template
        """
        rule_found = True
        message = ""
        try:
            message = self.templates.create_message(sys_act)
        except BaseException as error:
            rule_found = False
            self.logger.error(error)
            raise(error)

        # inform if no applicable rule could be found in the template file
        if not rule_found:
            self.logger.info('Could not find a fitting rule for the given system act!')
            self.logger.info("System Action: " + str(sys_act.type)
                             + " - Slots: " + str(sys_act.slot_values))

        # self.logger.dialog_turn("System Action: " + message)
        return message


    def _initialise_language(self, language: Language):
        """
            Loads the correct template file based on which language has been selected
            this should only be called on the first turn of the dialog

            Args:
                language (Language): Enum representing the language the user has selected
        """
        if language == Language.ENGLISH:
            if self.template_english is None:
                self.template_filename = os.path.join(
                    os.path.dirname(os.path.abspath(__file__)),
                    '../../resources/nlg_templates/%sMessages.nlg' % self.domain.get_domain_name())
            else:
                self.template_filename = self.template_english
        if language == Language.GERMAN:
            if self.template_german is None:
                self.template_filename = os.path.join(
                    os.path.dirname(os.path.abspath(__file__)),
                    '../../resources/nlg_templates/{}MessagesGerman.nlg'.format(
                        self.domain.get_domain_name()))
            else:
                self.template_filename = self.template_german

        self.templates = TemplateFile(self.template_filename, self.domain)
        self._add_additional_methods_for_template_file()

    def _add_additional_methods_for_template_file(self):
        """add the function prefixed by "_template_" to the template file interpreter"""
        for (method_name, method) in inspect.getmembers(type(self), inspect.isfunction):
            if method_name.startswith('_template_'):
                self.templates.add_python_function(method_name[10:], method, [self])

    def _template_genitive_s(self, name: str) -> str:
        if name[-1] == 's':
            return f"{name}'"
        else:
            return f"{name}'s"

    def _template_genitive_s_german(self, name: str) -> str:
        if name[-1] in ('s', 'x', 'ÃŸ', 'z'):
            return f"{name}'"
        else:
            return f"{name}s"


class TellerNLG(HandcraftedNLG):

    def __init__(self, domain: Domain, template_file: str = None, sub_topic_domains: Dict[str, str] = {},
                logger = None, template_file_german= None,
                language: Language = None):
        Service.__init__(self, domain=domain, sub_topic_domains=sub_topic_domains)

        self.logger = logger

    
    def generate_system_utterance(self, sys_act: SysAct = None) -> str:
        self.logger.info(f"sys act is {sys_act}")
        if sys_act.type == SysActionType.Bye:
            return "Glad to talk with you, bye!" 

        elif sys_act.type == SysActionType.Welcome:
            return "Welcome!"

        elif sys_act.type == SysActionType.Request:
            return self._process_request(sys_act)

        elif sys_act.type == SysActionType.InformByName:
            return self._process_solusions(sys_act)

        elif sys_act.type == SysActionType.RequestMore:
            return "You're welcome. What else can I do for you?"
        else:
            self.logger.info(f"let's check the type {sys_act}")
            return "Sorry, I don't understand!"


    def _process_solusions(self, sys_act: SysAct = None):
        # need to change the sys act...
        solutions = sys_act.get_values('courses')
        ret = f"To get {sys_act.get_values('total_credits')[0]} credits, there are {len(solutions)} solution(s). \n"

        for sid, sol in enumerate(solutions):
            ret += f"Solution {sid}: \n"
            ret += self._aggregate_on_day(sol)
        return ret

    def _aggregate_on_day(self, solution):
        # TODO: make it state
        self.days = ["mon", "tue", "wed", "thur", "fri"]
        day_course = {}
        for course in solution:
            for day, dur in course[1]:
                if day not in day_course:
                    day_course[day] = []
                day_course[day].append(course[0])

        for key in day_course:
            day_course[key] = list(set(day_course[key]))

        ret = ''
        for day in self.days:
            if day not in day_course: continue
            ret += '\t' + day.capitalize() + ".:" + ", ".join(day_course[day])
            ret += "\n"
        assert len(ret) != 0
        return ret


    def _process_request(self, sys_act: SysAct = None):
        if "error" in sys_act.meta:
            slot = sys_act.meta["error"]
            self.logger.info(f"error: {slot}")
            return self._get_input_format(slot)
        elif "total_credits" in sys_act.slot_values:
            return "How many credits would you like to earn?"
        elif "user_schedules" in sys_act.slot_values:
            return "What are your regular personal schedules that you don't want to go conflicts with the courses? (e.g. Have to work on Monday morning.)"
        elif "fields" in sys_act.slot_values:
            return "What field do you prefer? (e.g., NLP, speech)"
        elif "formats" in sys_act.slot_values:
            return "Which lecture format do you prefer, lecture, project or seminar?"
        else:
            raise NotImplementedError(f"sys_act be like {sys_act}")


    def _get_input_format(self, slot):
        if slot == self.domain.total_credits:
            return "The total credit is required. Its range is [12-60] and it should be a multiple of 3. Could you re-enter the value?"
        elif slot == self.domain.user_schedules:
            return "Sorry, we don't understand. If you don't have any schedule, can type 'don't care'. We currently only support formats of [day morning/afternoon]. For example, 'Have meetings on every Monday afternoon.'"
        elif slot == self.domain.fields:
            return "Sorry, we couldn't recognize the field. You can choose from the following fields: Programming, general AI, Math, CogSci, Linguistics, Natural Language Processing(NLP), Computer Vision(CV), Speech, Software Engineering, Database. If you don't care about the fileds, could just type 'don't care'. "
        elif slot == self.domain.formats:
            return "Please choose from 'lecture', 'project' and 'seminar'. If you don't have any format preference, you could type 'don't care'."
        